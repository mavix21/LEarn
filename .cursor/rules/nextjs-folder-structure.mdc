---
description: 
globs: 
alwaysApply: false
---
# Next.js Folder Structure

## /app (App router)

You must apply the rules of Feature-Sliced Design. Feature-Sliced Design (FSD) is an architectural methodology for scaffolding front-end applications. Simply put, it's a compilation of rules and conventions on organizing code. The main purpose of this methodology is to make the project more understandable and stable in the face of ever-changing business requirements.

Here is a simple project that implements FSD (in Next.js):

- ðŸ“ app
  - ðŸ“ (app)
  - ðŸ“ _pages
  - ðŸ“ _shared

These top-level folders are called layers. Let's look deeper:

- ðŸ“‚ (app)
  - ðŸ“ dashboard
    - ðŸ“„ page.tsx
    - ðŸ“„ layout.tsx
  - ðŸ“„ page.tsx
  - ðŸ“„ layout.tsx
- ðŸ“‚ _pages
  - ðŸ“ home
  - ðŸ“‚ article-reader
    - ðŸ“ ui
    - ðŸ“ api
  - ðŸ“ settings
- ðŸ“‚ _shared
  - ðŸ“ ui
  - ðŸ“ api

Folders inside ðŸ“‚ _pages are called slices. They divide the layer by domain (in this case, by pages).

Folders inside ðŸ“‚ app, ðŸ“‚ shared, and ðŸ“‚ pages/article-reader are called segments, and they divide slices (or layers) by technical purpose, i.e. what the code is for.

Layers, slices, and segments form a hierarchy like this:

Pictured above: three pillars, labeled left to right as "Layers", "Slices", and "Segments" respectively.

The "Layers" pillar contains seven divisions arranged top to bottom and labeled "(app)", "_pages", "_widgets", "_features", "_entities", and "_shared". The "_entities" division is connected to the second pillar "Slices" in a way that conveys that the second pillar is the content of "_entities".

The "Slices" pillar contains three divisions arranged top to bottom and labeled "user", "post", and "comment". The "post" division is connected to the third pillar "Segments" in the same way such that it's the content of "post".

The "Segments" pillar contains three divisions, arranged top to bottom and labeled "ui", "model", and "api".

### Layers

Layers are standardized across all FSD projects. You don't have to use all of the layers, but their names are important. There are currently seven of them (from top to bottom):

1. App â€” everything that makes the app run â€” routing (app router), entrypoints, global styles, providers.
2. Pages â€” full pages or large parts of a page in nested routing.
3. Widgets â€” large self-contained chunks of functionality or UI, usually delivering an entire use case.
4. Features â€” reused implementations of entire product features, i.e. actions that bring business value to the user.
5. Entities â€” business entities that the project works with, like user or product.
6. Shared â€” reusable functionality, especially when it's detached from the specifics of the project/business, though not necessarily.

> [!IMPORTANT]  
> Layers App and Shared, unlike other layers, do not have slices and are divided into segments directly. However, all other layers â€” Entities, Features, Widgets, and Pages, retain the structure in which you must first create slices, inside which you create the segments.


> [!IMPORTANT]  
> The trick with layers is that modules on one layer can only know about and import from modules from the layers strictly below.

### Segments

Slices, as well as layers App and Shared, consist of segments, and segments group your code by its purpose. Segment names are not constrained by the standard, but there are several conventional names for the most common purposes:

- ui â€” everything related to UI display: UI components, date formatters, styles, etc.
- api â€” backend interactions: request functions, data types, mappers, etc.
- model â€” the data model: schemas, interfaces, stores, and business logic.
- lib â€” library code that other modules on this slice need.
- config â€” configuration files and feature flags.

Usually these segments are enough for most layers, you would only create your own segments in Shared or App, but this is not a rule.

### Advantages

- Uniformity: Since the structure is standardized, projects become more uniform, which makes onboarding new members easier for the team.

- Stability in face of changes and refactoring: A module on one layer cannot use other modules on the same layer, or the layers above. This allows you to make isolated modifications without unforeseen consequences to the rest of the app.

- Controlled reuse of logic: Depending on the layer, you can make code very reusable or very local. This keeps a balance between following the DRY principle and practicality.

- Orientation to business and users needs: The app is split into business domains and usage of the business language is encouraged in naming, so that you can do useful product work without fully understanding all other unrelated parts of the project.

## /src

This folder must be divided into domains (the "Slices" mentioned above). In each domain, will be implemented the use cases asociated with that domain in the form of server actions. One folder per server action.